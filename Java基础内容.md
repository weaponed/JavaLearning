1. **基本数据类型**

   | 数据类型 | 字节 | 默认值   |
   | -------- | ---- | -------- |
   | byte     | 1    | 0        |
   | short    | 2    | 0        |
   | int      | 4    | 0        |
   | long     | 8    | 0        |
   | float    | 4    | 0.0f     |
   | double   | 8    | 0.0d     |
   | char     | 2    | '\u0000' |
   | boolean  | 4    | false    |

2. **面向对象的特征**

   - **继承**： 子类继承父类的特征和行为。子类可以有父类的**非私有**方法、属性；子类也可以对父类进行扩展，重写父类的方法。继承会提高代码的耦合性

   - **多态**：多态是指程序中定义的引用变量所指向的具体类型与该对象所调用的方法并不确定，只有在具体运行时才确定（重载与重写都能被称为多态，其中重载体现了编译时的多态，重写体现运行时的多态）

     多态存在的三个条件：

     1. 继承关系
     2. 子类重写父类的方法
     3. 父类的引用指向子类对象

   - **封装**：把描述一个对象属性和行为的代码封装在一个模块中，即一个类中，属性用变量定义，行为使用方法定义，方法可以方位同一对象的属性

   - **抽象**：把现实中的对象抽象为类。分为过程抽象(类的方法)和数据抽象(类的属性)

3. **包装类型**

   | 基本类型 | 包装类型  |
   | -------- | --------- |
   | byte     | Byte      |
   | short    | Short     |
   | int      | Integer   |
   | long     | Long      |
   | float    | Float     |
   | double   | Double    |
   | char     | Character |
   | boolean  | Boolean   |

   区别：

   - 声明方式：基本类型不需要new关键字，包装类型需要使用new关键字分配存储空间
   - 存储位置：基本类型是将变量直接存在栈中，而包装类型是将对象存放在堆区，通过引用来使用
   - 初始值：基本类型都会有初始值，而包装类型初始为null；

4. **'=='与'equals'区别**

   - ==比较的是两个引用在内存中指向的是否为同一个对象，即比较对象在内存中的位置是否相同
   - equals用来比较变量值是否相同，或者两个对象的内容是否相同

5. **栈(stack)、堆(heap)、方法区(method area)**

   - 栈区：
     1. 每个线程包含一个栈区，栈区中只保存基本数据类型的变量和自定义对象的**引用**
     2. 每个栈中的数据都是私有的，其他线程不能访问
     3. 栈分为三个部分：基本类型变量区、执行环境上下文、操作指令区（存放操作指令）
   - 堆区
     1. 存储的全都是对象，每个对象都包含与之对应的class信息
     2. jvm只有一个堆区，被所有线程共享，队中不存放基本类型和对象引用
   - 方法区
     1. 又叫静态区，跟堆一样，被所有的线程共享。包含所有的class和static变量
     2. 方法区中包含的都是在整个程序中永远唯一的元素

6. [接口与抽象类][1]

   [1]: https://github.com/weaponed/JavaLearning/blob/master/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.md	"接口与抽象类"



7. 访问权限

   |        | private | default | protected | public |
   | ------ | ------- | ------- | --------- | ------ |
   | 当前类 | true    | true    | true      | true   |
   | 同包   |         | true    | true      | true   |
   | 子类   |         |         | true      | true   |
   | 其他   |         |         |           | true   |

   注意：如果子类方法重写了父类的方法，那么子类中该方法的访问权限不允许低于父类的访问级别，这是因为需要保证在任何可以使用父类实例的地方都可以使用子类实例

   类的成员变量不能为public，因为这么做的话就失去了对这个变量修改行为的控制，客户端可以随意修改。
   
8. equals()与HashCode()

   * equals():原生的equals比较的也是引用地址，但重写之后的equals一般可以比较对象的内容是否相等，一般用于集合元素的比较，用来判断集合元素是否重复
   * HashCode():根据对象的值计算其物理存储位置，即hash值，对于值equals的两个对象，他们的hashcode一定相等；即使值不相等，也有可能由相同的hash值，因此在hashMap中，hash值相等的节点形成了链表
   * equals与hashCode的比较
     + 两个对象equals，则hashCode一定相等
     + 两个对象不equals，则hashCode不一定不相等
     + 两个对象hashCode相等，则对象不一定equals，因为可能存在地址冲突
     + 两个对象hashCode不相等，对象一定不equals

9. Java类中各部分执行顺序

   * 若类还未被加载
     1. 执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。（<u>*静态初始化块与静态变量在类第一次加载的时候就被初始化*</u>）
     2. 执行子类的静态代码块和静态变量初始化。
     3. 执行父类的初始化块和普通成员变量
     4. 父类构造器
     5. 子类初始化块和普通成员变量
     6. 子类构造器
   * 若类已经被加载，则静态代码块和静态变量初始化就不会重复执行，直接执行与实例对象相关的变量初始化和构造方法

10. final关键字

    final关键字可以用于修饰类、方法、变量

    * 当final修饰一个类时，表明这个类不能被继承。final类中成员变量可以根据需要设置为final，但是final类中的方法被隐式的指定为final方法
    * 当final修饰一个方法时，表明这个方法不能被重写（类中的private方法会被隐式的定义为final）
    * 修饰变量时final用的最多的地方，final成员变量表示常量，只能被赋值一次，赋值后不能改，final变量声明时就要赋值，不然会报错。
      + 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不可修改，
      + 当final修饰一个引用类型时，则在对象初始化之后便不能再指向其他对象，但是指向对象的内容是可以修改的
      + 当final修饰方法中的变量时，说明该变量是只读的

11. 



   

