1. **基本数据类型**

   | 数据类型 | 字节 | 默认值   |
   | -------- | ---- | -------- |
   | byte     | 1    | 0        |
   | short    | 2    | 0        |
   | int      | 4    | 0        |
   | long     | 8    | 0        |
   | float    | 4    | 0.0f     |
   | double   | 8    | 0.0d     |
   | char     | 2    | '\u0000' |
   | boolean  | 4    | false    |

2. **面向对象的特征**

   - **继承**： 子类继承父类的特征和行为。子类可以有父类的**非私有**方法、属性；子类也可以对父类进行扩展，重写父类的方法。继承会提高代码的耦合性

   - **多态**：多态是指程序中定义的引用变量所指向的具体类型与该对象所调用的方法并不确定，只有在具体运行时才确定（重载与重写都能被称为多态，其中重载体现了编译时的多态，重写体现运行时的多态）

     多态存在的三个条件：

     1. 继承关系
     2. 子类重写父类的方法
     3. 父类的引用指向子类对象

   - **封装**：把描述一个对象属性和行为的代码封装在一个模块中，即一个类中，属性用变量定义，行为使用方法定义，方法可以方位同一对象的属性

   - **抽象**：把现实中的对象抽象为类。分为过程抽象(类的方法)和数据抽象(类的属性)

3. **包装类型**

   | 基本类型 | 包装类型  |
   | -------- | --------- |
   | byte     | Byte      |
   | short    | Short     |
   | int      | Integer   |
   | long     | Long      |
   | float    | Float     |
   | double   | Double    |
   | char     | Character |
   | boolean  | Boolean   |

   区别：

   - 声明方式：基本类型不需要new关键字，包装类型需要使用new关键字分配存储空间
   - 存储位置：基本类型是将变量直接存在栈中，而包装类型是将对象存放在堆区，通过引用来使用
   - 初始值：基本类型都会有初始值，而包装类型初始为null；

4. **'=='与'equals'区别**

   - ==比较的是两个引用在内存中指向的是否为同一个对象，即比较对象在内存中的位置是否相同
   - equals用来比较变量值是否相同，或者两个对象的内容是否相同

5. **栈(stack)、堆(heap)、方法区(method area)**

   - 栈区：
     1. 每个线程包含一个栈区，栈区中只保存基本数据类型的变量和自定义对象的**引用**
     2. 每个栈中的数据都是私有的，其他线程不能访问
     3. 栈分为三个部分：基本类型变量区、执行环境上下文、操作指令区（存放操作指令）
   - 堆区
     1. 存储的全都是对象，每个对象都包含与之对应的class信息
     2. jvm只有一个堆区，被所有线程共享，队中不存放基本类型和对象引用
   - 方法区
     1. 又叫静态区，跟堆一样，被所有的线程共享。包含所有的class和static变量
     2. 方法区中包含的都是在整个程序中永远唯一的元素

6. [接口与抽象类][1]

<<<<<<< HEAD
7. 访问权限

   |        | private | default | protected | public |
| ------ | ------- | ------- | --------- | ------ |
   | 当前类 | true    | true    | true      | true   |
   | 同包   |         | true    | true      | true   |
   | 子类   |         |         | true      | true   |
   | 其他   |         |         |           | true   |
   
   注意：如果子类方法重写了父类的方法，那么子类中该方法的访问权限不允许低于父类的访问级别，这是因为需要保证在任何可以使用父类实例的地方都可以使用子类实例
   
   类的成员变量不能为public，因为这么做的话就失去了对这个变量修改行为的控制，客户端可以随意修改。
   
   [1]: https://github.com/weaponed/JavaLearning/blob/master/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.md	"接口与抽象类"
   
=======
[1]: https://github.com/weaponed/JavaLearning/blob/master/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.md	"接口与抽象类"
>>>>>>> e1c905468e4266e581be66f8f0d572fccd4a5d97
   

